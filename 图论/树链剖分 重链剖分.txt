#include <iostream>
#include <algorithm>
#include <string>
#include <cstring>
#include <stack>
#include <deque>
#include <cmath>
#include <queue>
#include <set>
#include <bitset>
#include <map>
#include <unordered_map>
using namespace std;
#define int long long
const int N=1e5+10;
int n,m,root,mod,x,y,z,op;
vector<int> arr[N];
int w[N],fa[N],sz[N],son[N],dep[N],top[N],id[N],nw[N];
int tot;

void dfs1(int u,int father)
{
  fa[u]=father,sz[u]=1,dep[u]=dep[father]+1;
  for(auto v:arr[u])
  {
    if(v==father) continue;
    dfs1(v,u);
    sz[u]+=sz[v];
    if(sz[son[u]]<sz[v])
    {
      son[u]=v;
    }
  }
}

void dfs2(int u,int t)
{
  top[u]=t,id[u]=++tot,nw[tot]=w[u]%mod;
  if(!son[u]) return;
  dfs2(son[u],t);
  for(auto v:arr[u])
  {
    if(v==fa[u]||v==son[u])
    {
      continue;
    }
    dfs2(v,v);
  }
}

struct tree
{
  int l,r,sum,lazy;
}tr[4*N];

void pushup(int u)
{
  tr[u].sum=(tr[u*2].sum+tr[u*2+1].sum)%mod;
}

void pushdown(int u)
{
  if(tr[u].lazy)
  {
    tr[u*2].lazy=(tr[u*2].lazy+tr[u].lazy)%mod;
    tr[u*2+1].lazy=(tr[u*2+1].lazy+tr[u].lazy)%mod;
    tr[u*2].sum=(tr[u*2].sum+tr[u].lazy*(tr[u*2].r-tr[u*2].l+1))%mod;
    tr[u*2+1].sum=(tr[u*2+1].sum+tr[u].lazy*(tr[u*2+1].r-tr[u*2+1].l+1))%mod;
    tr[u].lazy=0;
  }
}

void build(int u,int l,int r)
{
  tr[u].l=l;
  tr[u].r=r;
  tr[u].lazy=0;
  if(l==r)
  {
    tr[u].sum=nw[l]%mod;
    return;
  }
  int mid=l+r>>1;
  build(u*2,l,mid);
  build(u*2+1,mid+1,r);
  pushup(u);
}

int query(int u,int l,int r)
{
  if(l<=tr[u].l&&tr[u].r<=r)
  {
    return tr[u].sum%mod;
  }
  int mid=tr[u].l+tr[u].r>>1,res=0;
  pushdown(u);
  if(l<=mid) res=(res+query(u*2,l,r))%mod;
  if(mid<r) res=(res+query(u*2+1,l,r))%mod;
  
  return res%mod;
}

int query_path(int u,int v)
{
  int res=0;
  while(top[u]!=top[v])
  {
    if(dep[top[u]]<dep[top[v]]) swap(u,v);
    res=(res+query(1,id[top[u]],id[u]))%mod;
    u=fa[top[u]];
  }
  if(dep[u]<dep[v]) swap(u,v);
  res=(res+query(1,id[v],id[u]))%mod;
  return res%mod;
}

void update(int u,int l,int r,int k)
{
  k%=mod;
  if(l<=tr[u].l&&tr[u].r<=r)
  {
    tr[u].lazy=(tr[u].lazy+k)%mod;
    tr[u].sum=(tr[u].sum+k*(tr[u].r-tr[u].l+1))%mod;
    return;
  }
  pushdown(u);
  int mid=tr[u].l+tr[u].r>>1;
  if(l<=mid) update(u*2,l,r,k);
  if(mid<r) update(u*2+1,l,r,k);
  pushup(u);
}

void update_path(int u,int v,int k)
{
  while(top[u]!=top[v])
  {
    if(dep[top[u]]<dep[top[v]]) swap(u,v);
    update(1,id[top[u]],id[u],k);
    u=fa[top[u]];
  }
  if(dep[u]<dep[v]) swap(u,v);
  update(1,id[v],id[u],k);
}

void update_tree(int u,int k)
{
  update(1,id[u],id[u]+sz[u]-1,k);
}

int query_tree(int u)
{
  return query(1,id[u],id[u]+sz[u]-1)%mod;
}

signed main()
{
    ios::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
    
    cin>>n>>m>>root>>mod;
    for(int i=1;i<=n;i++)
    {
      cin>>w[i];
    }
    for(int i=1;i<n;i++)
    {
      cin>>x>>y;
      arr[x].push_back(y);
      arr[y].push_back(x);
    }
    dfs1(root,0);
    dfs2(root,root);

    build(1,1,tot);
    while(m--)
    {
      cin>>op;
      if(op==1)
      {
        cin>>x>>y>>z;
        update_path(x,y,z);
      }
      else if(op==2)
      {
        cin>>x>>y;
        cout<<query_path(x,y)%mod<<endl;
      }
      else if(op==3)
      {
        cin>>x>>z;
        update_tree(x,z);
      }
      else
      {
        cin>>x;
        cout<<query_tree(x)%mod<<endl;
      }
    }

    return 0;
}
